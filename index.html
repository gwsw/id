<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Intensity Mapper</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>
<br>
<table id="ctls">
 <tr>
  <td> Input </td>
  <td> Output </td>
 </tr>
 <tr>
  <td>
   <select name="input" id="sel_input" onchange="Game._event_io_changed()">
    <option value="sine"> Sine wave </option>
   </select>
  </td>
  <td>
   <select name="output" id="sel_output" onchange="Game._event_io_changed()">
    <option value="rect"> Rect </option>
    <option value="widen"> Widen </option>
    <option value="fire"> Fire </option>
    <option value="pcircles"> Circles </option>
   </select>
  </td>
  <td>
   <input type="number" id="jags" value="7" size="5" onchange="Game._event_io_changed()" style="display:none"/> <span id="jags_hdr">jags</span>
   <input type="number" id="num_pcircles" value="1" size="5" onchange="Game._event_io_changed()" style="display:none"/><span id="pcircles_hdr">circles</span>
  </td>
 </tr>
</table>

<script src="../jlib/gfx.js"></script>

<script>

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    sine_period            : 3500,
	off_color_r            : 24,
	off_color_g            : 24,
	off_color_b            : 24,

	pc_min_radius          : 40,
	pc_max_radius          : 200,

    color_bg               : "002050",
    color_black            : "000000",
    //color_grid             : "f00000",
    color_meter_fg         : "a05010",
    color_meter_bg         : "000000",
    color_pcircles_bg      : "a05010",
};

// --------------------------------------------------------------------
class ID { // interface
    constructor(input, output) {
        this.input = input;
        this.output = output;
        this.set_intensity(0);
    }
    set_intensity(intens) {
        this.intens = intens;
    }
    update() {
        this.set_intensity(this.input.get_intensity());
    }
    draw(gfx, x, y, w, h) {
        this.output.set_intensity(this.intens);
        this.output.draw(gfx, x, y, w, h);
    }
};

// --------------------------------------------------------------------
class ID_Input { // interface
    constructor() {
    }
    get_intensity() { pure(); }
};

// --------------------------------------------------------------------
class ID_Output { // interface
    constructor() { this.intens = 0; }
    set_intensity(intens) { this.intens = intens; }
    draw(gfx, x, y, w, h) { pure(); }
};

// --------------------------------------------------------------------
class ID_RectMeter extends ID_Output {
    constructor(fg, bg) {
        super();
        this.fg = fg;
        this.bg = bg;
    }
    draw(gfx, x, y, w, h) {
        gfx.draw_rect(x, y, w, h, this.bg);
        let wa = w * this.intens;
        gfx.draw_rect(x, y, wa, h, this.fg);
    }
};

// --------------------------------------------------------------------
class ID_PCirclesCircle {
	constructor() {
		this.min_radius = /*config.pc_min_radius*/0 + randu((((.7))) /*WTF is this???*/ * (config.pc_max_radius - config.pc_min_radius));
		this.max_radius = this.min_radius + randu(config.pc_max_radius - this.min_radius);
		this.color = Color.random(config.off_color_r, config.off_color_g, config.off_color_b);
		this.placed = false;
	}
    draw(gfx, x, y, w, h, intens) {
		if (!this.placed) {
			this.x = config.pc_max_radius + randu(w - 2*config.pc_max_radius);
			this.y = config.pc_max_radius + randu(h - 2*config.pc_max_radius);
			this.placed = true;
		}
		const radius = config.pc_min_radius + intens * (this.max_radius - this.min_radius);
		gfx.draw_circle(this.x, this.y, radius, this.color);
	}
};

class ID_PCircles extends ID_Output {
    constructor(bg, num_circles = 1) {
		super();
		this.bg = bg;
		this.circles = [];
		for (let cx = 0; cx < num_circles; ++cx) {
			const circle = new ID_PCirclesCircle();
			this.circles.push(circle);
		}
	}
    draw(gfx, x, y, w, h) {
        gfx.draw_rect(x, y, w, h, this.bg);
		for (const circle of this.circles) {
			circle.draw(gfx, x, y, w, h, this.intens);
		}
	}
};

// --------------------------------------------------------------------
class ID_WidenMeter extends ID_Output {
    constructor(fg, bg) {
        super();
        this.fg = fg;
        this.bg = bg;
    }
    draw(gfx, x, y, w, h) {
        gfx.draw_rect(x, y, w, h, this.bg);
        let wa = w * this.intens / 2;
        ///gfx.draw_rect(x + wa, y, 2*wa, h, this.fg);
        gfx.draw_rect(x + w/2 - wa, y, 2*wa, h, this.fg);
    }
};

// --------------------------------------------------------------------
class ID_FireMeter extends ID_Output {
    constructor(jags) {
        super();
        this.jags = [];
        while (this.jags.length < jags/2)
            this.jags.push(randu(1000) / 1000);
        this.bg = config.color_meter_bg;
        this.fg = Color.random();
    }
    draw(gfx, x, y, w, h) {
        gfx.draw_rect(x, y, w, h, this.bg);
        this.draw2(gfx, x, y, w, h, false);
        this.draw2(gfx, x, y, w, h, true);
    }
    draw2(gfx, x, y, w, h, inv) {
        const rsv = 0.06;
        const jlen = this.jags.length;
        const klen = 2*jlen-1;
        const step = w / (2*klen);
        let pts = [ new Point(x,yy(y,h,inv)), new Point(x,yy(y+rsv*h,h,inv)) ];
        x += step;
        for (let i = 0; i < klen; ++i) {
            const jag = i < jlen ? this.jags[i] : this.jags[klen-i-1];
            const fr = rsv + (jag * this.intens * (1 - rsv));
            pts.push(new Point(x, yy(y+h*fr,h,inv)));
            x += step;
            pts.push(new Point(x, yy(y+h*rsv,h,inv)));
            x += step;
        }
        pts.push(new Point(x-step, yy(y,h,inv)));
        gfx.draw_poly(pts, 0, 0, 0, 1, this.fg, this.fg);
    }
};

function yy(y,h,inv) {
    return inv ? h-y : y;
}

// --------------------------------------------------------------------
class ID_Sine extends ID_Input {
    constructor(period) {
        super();
        if (period == 0) period = 1;
        this.period = period;
    }
    get_intensity() {
        const phase = (now() % this.period) / this.period;
        let intens = Math.sin(2*Math.PI * phase);
        if (intens < 0) intens = -intens;
        return intens;
    }
};

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.stopping = false;
        this.new_id();
    }
    new_id() {
        const input_type = el("sel_input").selectedIndex;
        const output_type = el("sel_output").selectedIndex;
        const input = Game.new_input(input_type);
        const output = Game.new_output(output_type);
        this.id = input && output ? new ID(input, output) : null;
    }
    static new_input(type) {
        switch (type) {
        case 0: return new ID_Sine(5500);
        }
        return null;
    }
    static new_output(type) {
        switch (type) {
        case 0:
            return new ID_RectMeter(config.color_meter_fg, config.color_meter_bg);
        case 1:
            return new ID_WidenMeter(config.color_meter_fg, config.color_meter_bg);
        case 2:
            const jags = el("jags").valueAsNumber;
            return new ID_FireMeter(jags);
		case 3:
            const num_pcircles = el("num_pcircles").valueAsNumber;
			return new ID_PCircles(config.color_pcircles_bg, num_pcircles);
        }
        return null;
    }
    resize(width, height) {
        const s = Math.min(width, height);
        this.gfx.set_font_size(s*.040);
        this.draw();
    }
    run() {
        const intens = this.id.input.get_intensity();
        this.id.set_intensity(intens);
        this.draw();
        if (this.stopping) {
            this.stopping = false;
            return false;
        }
        return true;
    }
    stop() {
        this.stopping = true;
        while (this.stopping) {
            run_game();
        }
    }
    draw() {
        this.gfx.clear(config.color_bg);
        const canvas = this.gfx.canvas_dims();
        this.id.draw(this.gfx, 0, 0, canvas.w, canvas.h);
		if (config.color_grid) {
			for (let x=0; x<canvas.w; x+=100) { this.gfx.draw_rect(x,0,1,canvas.h, config.color_grid); }
			for (let y=0; y<canvas.h; y+=100) { this.gfx.draw_rect(0,y,canvas.w,1, config.color_grid); }
		}
    }
    event_mouse(event, x, y) {
        if (event == Game.MOUSE_DOWN) {
            ///this.draw();
        }
    }
    static _event_io_changed() {
        if (_game != null) { _game.stop(); }
        _game.new_id();
		const ox = el("sel_output").selectedIndex;
        el("jags_hdr")    .style.display = (ox == 2) ? "block" : "none";
        el("jags")        .style.display = (ox == 2) ? "block" : "none";
		el("pcircles_hdr").style.display = (ox == 3) ? "block" : "none";
		el("num_pcircles").style.display = (ox == 3) ? "block" : "none";
    }

    static _event_mousedown(e) { if (_game != null) _game.event_mouse(Game.MOUSE_DOWN, e.offsetX, e.offsetY); }
    static _event_mouseup(e) { if (_game != null) _game.event_mouse(Game.MOUSE_UP, e.offsetX, e.offsetY); }
    static _event_mousemove(e) { if (_game != null) _game.event_mouse(Game.MOUSE_MOVE, e.offsetX, e.offsetY); }

    static MOUSE_DOWN = 0;
    static MOUSE_UP   = 1;
    static MOUSE_MOVE = 2;
}; // class Game

// --------------------------------------------------------------------
function canvas_to_window() {
    const canvas = el("canvas");
    const s = 20;
    canvas.width = window.innerWidth - s;
    canvas.height = window.innerHeight - 3* el("ctls").offsetHeight;
    return canvas;
}

function canvas_resize() {
    const canvas = canvas_to_window();
    if (_game != null) _game.resize(canvas.width, canvas.height);
}

function run_game() {
    if (_game == null) return;
    if (_game.run())
        window.requestAnimationFrame(run_game);
}

function main() {
    munge_config();
    const canvas = canvas_to_window();
    const gfx = new Graphics(canvas.getContext("2d"));
    _game = new Game(gfx);
    _game.resize(canvas.width, canvas.height);
    window.addEventListener('resize', canvas_resize, false);
    document.addEventListener('mousedown', Game._event_mousedown);
    document.addEventListener('mouseup', Game._event_mouseup);
    document.addEventListener('mousemove', Game._event_mousemove);
    Game._event_io_changed();
    run_game();
}

function pure() {
    console.error("attempt to call a PURE function, you degenerate!");
}

</script>
</body>
</html>
